{
  "content": {
    "1": {
      "summary": "匹配单个字符，由最简单的匹配规则入手，介绍正则表达式的用法。"
    },
    "1.1": {
      "summary": "纯文本匹配，顾名思义，正则表达式内容为纯文本去匹配目标字符串。",
      "example":{
        "text": "hello, my name is Ben. Please visit my website at http://www.format.com/.",
        "reg": "Ben",
        "result": "hello, my name is _Ben_. Please visit my website at http://www.format.com/."
      }
    },
    "1.1.1": {
      "summary": "如果我们想把多个同样的字符都匹配出来，需要设置匹配模式为全局，即开始global属性，简写g。",
      "example":{
        "text": "hello, my name is Ben. Please visit my website at http://www.format.com/.",
        "reg": "my",
        "configs": "g",
        "result": "hello, _my_ name is Ben. Please visit _my_ website at http://www.format.com/."
      }
    },
    "1.1.2": {
      "summary": "默认情况下JavaScript的正则表达式是区分大小写的，也就是说A是匹配不到a的，我们需要设置全局配置i来控制不区分大小写。"
    },
    "1.2": {
      "summary": "在正则表达式中有个特殊字符.可以匹配任何一个单字字符（亦被称为元字符，后面还会看到很多元字符）。",
      "example": {
        "text": "salse1.xls, orders3.xls, salse2.xls",
        "reg": "sales.",
        "configs": "g",
        "result": "_salse1_.xls, orders3.xls, _salse2_.xls"
      }
    },
    "1.3": {
      "summary": ".是有特殊含义的元字符，如果我想要匹配.这个字符时需要在字符前面加上___,对齐进行转义。 举个例子，还是上面文件名字符串。",
      "example": {
        "text": "europe2.xls, na1.xls, na2.xls",
        "reg": ".a.___.",
        "configs": "g",
        "result": "europe2.xls, _na1._xls, _na2._xls,"
      }
    },
    "2": {
      "summary": "匹配一组字符",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": ""
      }
    },
    "2.1": {
      "summary": "在上例中我们可以用.a来匹配na,sa，但是如果文件名中有ca1.xls这样的文件名时，别忘了.也是可以匹配c的。那么如果还用.a的话，那么无疑ca1也会被匹配。既然只想要找出n和s使用可以匹配任意字符的.肯定是不行的。在正则表达式里，我们可以使用元字符[和]定义一个字符集，这俩个元字符之间的所有字符都是集合的组成部分，字符集合的匹配结果是能够与该集合里的任意一个成员相匹配的文本",
      "example": {
        "text": "salse1.xls, na2.xls, ca1.xls",
        "reg": "[ns]a",
        "configs": "g",
        "result": "_sa_lse1.xls, _na_2.xls, ca1.xls",
        "analyse": "[ns]可以匹配n或者s，后面紧接着a自然就可以匹配na，sa了。"
      }
    },
    "2.2": {
      "summary": "如果我们想选中的是类似na1.xls,na2.xls这样数组结尾的文件名，相对[ns]a.___.xls这个正则目前来看好像没什么问题，但是如果文档中包含类似nam.xls这样的文件名，那么这个正则就有问题了。这个问题可以使用如下所以的字符结合来解决。",
      "example": {
        "text": "na1.xls, na2.xls, sa1.xls，ca1.xls, nam.xls",
        "reg": "[ns]a[0123456789]___.xls",
        "configs": "g",
        "result": "_na1.xls_, _na2.xls_, _sa1.xls_，ca1.xls, nam.xls",
        "analyse": "[ns]a就不说了，[0123456789]是一个数字集合，他只能匹配这10个数字，nam.xls中na后跟m不是数字所以不会被匹配。",
        "more": {
          "title": "在正则表达式中我们经常会用到类似0到9这样的区间，因此就出现了[0-9]、[a-z]、[A-Z]这样的区间（当然也有汉字区间）。为了简化区间的写法，正则表达式里提供了-连字符来定义区间。",
          "lists": [
            "字符区间不仅限于数字，以下这些都是都是合法的字符区间：",
            "A-Z，匹配从A到Z的所有大写字母。",
            "a-z，匹配从a到z的所有小写字母。",
            "A-F，匹配从A到F的所有大写字母",
            "A-z，匹配从ASCII字符A到ASCII字符z的所有字母。这个模式一般不经常使用，因为这其中还包含]和^等在ASCII字符表里排列在Z和a之间的字符"
          ],
          "describe": "在使用[]配合连字符-使用时，需避免让这个区间的尾字符小于其首字符，（如[3-1]）这中区间是没有意义的，会让整个模式失效。-连字符是一个特殊的元字符，作为元字符他只能用在[和]之间，在字符集合以外的地方，-只是一个普通的字符，只能与-本身相匹配。因此在正则表达式里-字符不需要转义。"
        }
      }
    },
    "2.3": {
      "summary": "字符集合通常用来指定一组必须匹配其中之一的字符。但是在某些场合，我们需要分过来做，给出一组不需要得到的字符，换句话说，除了那个字符集合里的字符，其他字符都可以匹配。正则表达式里有一个更简明的办法：用元字符^来表明你想对一个字符集合进行取非匹配--这与逻辑非运算很相似，只是这里的操作数是字符集合而已。",
      "example": {
        "text": "na1.xls, ca1.xls, nam.xls",
        "reg": "[ns]a[^0-9]___.xls",
        "configs": "g",
        "result": "na1.xls, ca1.xls, _nam.xls_",
        "analyse": "[^0-9]标示对[0-9]集合内的十个字符做了排除，所以跟在na后面的只能是非数字。"
      }
    },
    "3": {
      "summary": "这里讲详细讨论使用更多的元字符去匹配特定的字符或字符类型",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": ""
      }
    },
    "3.1": {
      "summary": "关于字符转义其实很简单，就是说特殊字符即元字符不可以直接用来匹配自身，需要用___先转义后才能匹配自身。举个例子：",
      "example": {
        "text": "if (myArray[0] == 0)",
        "reg": "myArray[0]",
        "configs": "",
        "result": "没有回被匹配的字符",
        "analyse": "myArray[0]中myArray会匹配myArray字符串，但是[0]被解释成值匹配0的字符区间，所以最终会匹配的结果是myArray0,而不是myArray[0]。<br>myArray___[0___]，因为[]被转义了，会匹配字符串myArray[0]。加入要匹配myArray[0],myArray[1],myArray[2]之类的字符串需要用这样的正则表达式：myArray___[[0-9]___]。这个正则表达式先对外层的[]进行转义然后在匹配0-9的字符区间。</br>要匹配的任何一个元字符都需要加上反斜杠___作为前缀来转义，但是能够被转义的元字符并不局限于这里提到的。配对的元字符（比如[或]）不用作元字符时必须被转义，否则正则表达式分析器很可能会抛出一个错误。"
      }
    },
    "3.2": {
      "summary": "元字符大致可以分为两种：一种是用来匹配问本的（比如.），另一种是正则表达式的语法所要求的（比如[和]）。元字符有很多，接下来我们将讨论的是一些用来匹配各种空白字符的元字符",
      "example": {
        "text": "'101', 'Ben', 'Forta'",
        "reg": "___r___n___r___n（这个使用与windows系统",
        "configs": "",
        "result": "选中空白"
      }
    },
    "3.3": {
      "summary": "一些常用的字符类集合可以使用特殊元字符来代替。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": ""
      }
    },
    "3.3.1": {
      "summary": "前面我们曾介绍过[0-9]是[0123456789]的简写形式，他可以用来匹配任何一个数字，那么非数字的字符可以用[^0-9]来匹配。下表列出了匹配数字和非字符类的元字符。",
      "example": {
        "text": "myArray[0]",
        "reg": "myArray___[[___d]___]",
        "configs": "",
        "result": "_myArray[0]_",
        "analyse": "___d匹配数字"
      }
    },
    "3.3.2": {
      "summary": "任何一个字母数字字符（大小写均可）或下划线字符（等价于[a-zA-Z0-9_]）",
      "example": {
        "text": "11213，A1C2E3",
        "reg": "___w___d___w___d___w___d",
        "configs": "g",
        "result": "11213，_A1C2E3_",
        "analyse": " 在这个模式里，___w匹配字母数字下划线，___d匹配数字，整个表达式匹配3对 数字|字符|_和一个数字。"
      }
    },
    "3.3.3": {
      "summary": "匹配任何一个空白字符<br>用来匹配退格字符的[___b]元字符是一个特例：它不在类元字符___s的覆盖范围内，当然也就没有被排除在类元字符___S的覆盖范围外。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": ""
      }
    },
    "3.3.4": {
      "summary": "在正则表达式里，十六进制（逢16进1）数值要用前缀___x给出。比如说，___x0A对应于ASCII字符10（换行符），其效果等价于___n。<br> 在正则表达式里，八进制（逢8进1）数组要用前缀___0给出，数值本身可以是俩位或是三位，比如说，___011对应于ASCII字符9（制表符），其效果等价于___t。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "3.4": {
      "summary": "因为JavaScript引擎不支持这种用法，所以这里只是简单的列举出一些用法（见元字符列表），有兴趣的同学可以下去自己玩玩。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "4": {
      "summary": "这里介绍重复匹配",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "4.1": {
      "summary": "先考虑一个问题，如何构造一个匹配电子邮件地址的正则表达式，电子邮件的基本格式应该是如下所示： text@text.text，或许可以利用元字符写出这样一个正则：___w@___w___.___w。___w可以匹配所有的字母和数字字符（以及下划线字符_，这个字符在电子邮件地址里是是合法的）；@字符不需要被转义，但字符.需要。<br> 这里的这个正则本身没有任何错误，但是却只能匹配a@b.c形式的电子邮件，因为电子邮件各部分的字符串长度字符不能确定，这里就需要用到可以实现重复匹配的元字符。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "4.1.1": {
      "summary": "想要匹配同一个（组）字符（或字符集合）的多次重复，只要简单地给这个字符（或字符集合）加上+字符作为后缀就行了。+匹配一个或多个字符（至少一个；不匹配零个字符的情况）。<br>在给一个字符集合加上+后缀的时候，必须把+放在这个字符集合的外面，比如说，[0-9]+是正确的，[0-9+]则不是。[0-9+]其实也是一个合法的正则表达式，但它匹配的不是一个或多个数字，它定义了一个由数字0到9和+构成的字符集合，因而只能匹配一个单个的数字字符或加号。",
      "example": {
        "text": "Send personal email to ben@forta.com. For questions about a book use support@forta.com. Feel free to send unsolicited email to spam@forta.com (wouldn't it be nice if it were that simple, huh?).",
        "reg": "___w+@___w+___.___w+",
        "configs": "g",
        "result": "Send personal email to _ben@forta.com_. For questions about a book use _support@forta.com_. Feel free to send unsolicited email to _spam@forta.com_ (wouldn't it be nice if it were that simple, huh?)",
        "analyse": "这个模式把原始文本里的3个电子邮件都匹配到了。首先用第一个___w+匹配一个或多个字符数字，再用第二个___w+匹配@后面的一个或多个字符，然后在匹配一个.字符，最后第三个___w+匹配剩余的部分。"
      }
    },
    "4.1.2": {
      "summary": "+匹配一个或多个字符，但不匹配零个字符----+最少也要匹配一个字符，如果你想匹配一个可有可无的字符，这个时候需要用*元字符来完成。通过下面这个例子来了解元字符*的作用。",
      "example": {
        "text": "Hello .ben@forta.com is my email address.",
        "reg": "___w+[___w.]*@[___w.]+___.___w+",
        "configs": "",
        "result": "Hello ._ben@forta.com_ is my email address.",
        "analyse": "这个模式看起来或许复杂，但却不难理解。开头的___w+负责匹配电子邮件地址里的第一个字符（一个字母数字字符，不包括.字符）。接下来的[___w.]*负责匹配电子邮件地址里第一个字符之后的、@字符之前的所有字符----这个部分可以包含零个或多个字母数字字符和.字符。其他的部分前面都有解释。"
      }
    },
    "4.1.3": {
      "summary": "另一个非常有用的元字符是？。？只能匹配一个字符（或字符集合）的零次或一次出现，最多不超过一次----请仔细体会？与+和*的相似的区别之处。如果需要在一段文本里匹配某个特定的字符（或字符集合）而字符可能出现、也可能不出现，？无疑是最佳的选择。来看一个例子：",
      "example": {
        "text": "the URL is http://www.forta.com/, to connect securely use https://www.forta.com/ instead.",
        "reg": "https?://[___w./]+",
        "configs": "g",
        "result": "the URL is _http://www.forta.com/_, to connect securely use _https://www.forta.com/_ instead.",
        "analyse": "这个模式的开头部分是https?。？在这里的含义是：我前面的字符（s）要么不出现，要么最多出现一次。换句话说，https?://既可以匹配http://，也可以匹配https://"
      }
    },
    "4.2": {
      "summary": "正则表达式里的+、*和？解决了许多问题，但是是有些问题光靠他们还是不够，1)我们无法为它们将匹配的字符个数设定一个最大值，2）我们无法为它们将匹配的字符个数另行设定一个最小值，3）我们无法把它们将匹配的字符个数设定为一个精确数字，为了解决这些问题并让程序员对重复性匹配有更多的控制，正则表达式语言提供一个用来设定重复次数的语法。重复次数要用{和}字符来给出----把数值写在他们之间",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "4.2.1": {
      "summary": "如果你想为重复匹配次数设定一个精确的值，把那个数字写在{和}之间即可，比如说，{3}意味着模式里的前一个字符（或字符集合）必须在原始文本里连续重复出现3次才算是一个匹配。",
      "example": {
        "text": "#123abc",
        "reg": "#[0-9A-Fa-f]{6}",
        "configs": "",
        "result": "_#123abc_",
        "analyse": "[0-9A-Fa-f]集合里的字符出现6次"
      }
    },
    "4.2.2": {
      "summary": "{}语法还可以用来为重复匹配次数设定一个区间----也就是为重复匹配次数设计一个最小值和一个最大值。这种区间必须以{2,4}这样的形式给出----{2， 4}的含义是最少重复2次、最多重复4次。",
      "example": {
        "text": "4/8/03, 10-6-2004, 2/2/2, 01-01-01",
        "reg": "___d{1,2}[-___/]___d{1,2}[-___/]___d{2,4}",
        "configs": "g",
        "result": "_4/8/03_, _10-6-2004_, 2/2/2, _01-01-01_",
        "analyse": "这个正则用于匹配一个合法的月-日-年字符串。首先___d{1,2}将匹配一个或俩个数字字符（即日子和月份），___d{2,4}用来匹配年份，[-___/]用来匹配分隔符-或/。"
      }
    },
    "4.2.3": {
      "summary": "{}语法的最后一种用法是给出一个最小的重复次数（但不必给出一个最大值）。{}的这种用法与我们用来为重复匹配次数设定一个区间的{}语法很相似，只是省略了最大值部分而已。比如说，{3,}表示至少重复了3次，与之等价的说法是“必须重复3次或更多次”。",
      "example": {
        "text": "$496.80, $1290.69, $26.43",
        "reg": "___$___d{3,}___.___d{2}",
        "configs": "g",
        "result": "_$496.80_, _$1290.69_, $26.43",
        "analyse": "这个模式里，___$匹配$、___d{3,}匹配至少3位数字（也就是所有大于或等于$100美元的金额）、___.匹配.、___d{2}匹配小数点后面的俩位数字。<br>在进行这种重复次数匹配的时候一定要小心，如果遗漏了花括号里的逗号,，模式将变成（具体到这个例子）精确匹配3位数字而不再是匹配至少3位数字。"
      }
    },
    "4.3": {
      "summary": "？只能匹配零个或一个字符，{n}和{m,n}也有一个重复次数的上限：换句话说，这几种语法所定义的“重复次数”都是有限的。但这里介绍的其他重复匹配语法在重复次数方面都没有上限值，而这样做有时会导致过度匹配的现象。到目前为止还没遇到过度匹配的问题，但迟早会遇到，接下来我这样一个例子：匹配一个字符串中的类html标签。",
      "example": {
        "text": "this offer is not available to customers living in <bi>AK</bi> and <bi>HI</bi>",
        "reg": "<bi>.*?</bi>",
        "configs": "g",
        "result": "this offer is not available to customers living in _<bi>AK</bi>_ and _<bi>HI</bi>_",
        "analyse": "正则中在*后面跟了个?构成*对应的懒惰型匹配，从而正确匹配了2对标签，如果我们去掉?会发生什么呢？"
      }
    },
    "5": {
      "summary": "在某些场合，你需要且只需要对某段文本的特定位置进行匹配，这就引出了位置匹配的概念。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "5.1": {
      "summary": "位置用来解决在什么地方进行字符串匹配操作的问题。",
      "example": {
        "text": "The cat scattered his food all over the room。",
        "reg": "cat",
        "configs": "g",
        "result": "The _cat_ s_cat_tered his food all over the room。",
        "analyse": "模式cat把原始文本里的所有cat都找了出来，同时也包括单词scattered里也不例外。但是这并不是我们的预期，我只想找出单词cat，并对其进行替换成dog，但是结果却会出问题。 <br> 若要解决这问题办法只有一个：使用边界限定符，也就是正则表达式里用一些特么的元字符来表明我们想让匹配操作在什么位置（或边界）发生。"
      }
    },
    "5.2": {
      "summary": "第一种边界（也是最常用的边界）是由限定符___b指定的单词边界。顾名思义，___b用来匹配一个单词的开始或结尾。再回到那个例子，我们用上单词边界：",
      "example": {
        "text": "The cat scattered his food all over the room。",
        "reg": "___bcat___b",
        "configs": "g",
        "result": "The _cat_ scattered his food all over the room。",
        "analyse": "在原始文本里，单词cat的前后都有一个空格，而这将与模式___bcat___b相匹配（空格是用来分隔单词的字符之一）。而单词scattered中字符cat不能与这个模式相匹配，因为它前一个字符是s、后一个字符是t"
      }
    },
    "5.3": {
      "summary": "单词边界可以用来进行与单词有关的位置匹配（单词的开头、单词的结束、整个单词，等等）。字符串边界有着类似的用途，只不过是用来进行与字符串有关的位置匹配而已（字符串的开头、字符串的结束、整个字符串，等等）。用来定义字符串边界的元字符有俩个：一个用来定义字符串开头的^，另一个用来定义字符串结尾的$。",
      "example": {
        "text": "<?xml version='1.0' encoding='UTF-8'?> abc <?xml version='1.0' encoding='UTF-8'?>",
        "reg": "^___s<___?xml.*?___?>",
        "configs": "g",
        "result": "_<?xml version='1.0' encoding='UTF-8'?>_ abc <?xml version='1.0' encoding='UTF-8'?>",
        "analyse": "正则开始用^来修饰，标示从字符串开始匹配，所以只会匹配第一个，后面那个就不会匹配。可以去掉^看看结果。"
      }
    },
    "6": {
      "summary": "子表达式对正则表达式进行分组和归类。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "6.1": {
      "summary": "何为自表达式，废话不多说，我们看一个例子，匹配如下文本中的空格字符&1nbsp;。",
      "example": {
        "text": "WIndows&1nbsp;&1nbsp;2000, and other subjects.",
        "reg": "&1nbsp;{2,}",
        "configs": "g",
        "result": "啥都匹配不到",
        "analyse": "&1nbsp;是HTML语言中的非换行空个字符。这里使用模式&nbsp;{2,}的本意是希望它们能把&1nbsp;连续俩次或更多次的重复出现找出来，但它没能给出我们所预期的结果。为何会如此？因为{2,}只作用于紧挨着它的前一个字符--那是一个分号。如此一来这个模式只能匹配像&1nbsp;;;;;;这样的文本，但无法匹配&1nbsp;&1nbsp;。"
      }
    },
    "6.2": {
      "summary": "子表达式是一个更大的表达式的一部分；把一个表达式划分为一系列子表达式的目的是为了把那些子表达式当作一个独立元素来使用。子表达式必须用（和）括起来",
      "example": {
        "text": "WIndows&1nbsp;&1nbsp;2000, and other subjects.",
        "reg": "(&1nbsp;){2,}",
        "configs": "g",
        "result": "WIndows_&1nbsp;&1nbsp;_2000, and other subjects.",
        "analyse": "(&1nbsp;)是一个子表达式，他将被视为一个独立元素，而紧跟在它们后面的{2,}将作用于这个子表达式（不仅仅是分号）<br>子表达式的嵌套具体的例子详见实例篇匹配ip地址。"
      }
    },
    "7": {
      "summary": "回溯引用：前后一致匹配",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "7.1": {
      "summary": "回溯引用有什么用，考虑几个例子吧",
      "example": {
        "text": "<hh1>第一个标题</hh1> 第一个标题下的文字 <hh2>第二个标题</hh2> 第二个标题下的文字 <hh3>第三个标题</hh3> <hh4>第三个标题下文字</hh5>, ",
        "reg": "<hh1>.*?</hh1>, <hh[1-6]>.*?</hh[1-6]>",
        "configs": "g",
        "result": "分别会是啥结果呢",
        "analyse": ""
      }
    },
    "7.2": {
      "summary": "在讨论回溯引用之前，我们先看一个问题，这个问题不用回溯引用将根本无法解决。假设一段文本中有连续出现俩次的单词，希望把它找出来。显然在搜索某个单词的第二次出现时，这个单词必须是已知的。回溯引用允许正则表达式引用前面的匹配结果（具体到这里例子，就是前面匹配到的单词）",
      "example": {
        "text": "<hh1>第一个标题</hh1><hh2>第二个标题</hh3>",
        "reg": "<hh([1-6])>.*?</hh___1>",
        "configs": "g",
        "result": "_<hh1>第一个标题</hh1>_<hh2>第二个标题</hh3>",
        "analyse": "总共匹配了2个标题，但是模式中我们用(和)把[1-6]括了起来，使它成为了一个子表达式。这样<hh___1>用___1来引用这个子表达式了。子表达式([1-6])匹配数字1-6，___1只匹配与之相同的数字。这样一来<hh2>**</hh3>就不会被匹配了。"
      }
    },
    "7.3": {
      "summary": "在替换操作里，如果仅仅是替换简答的字母或是单词，完全用不着正则，但是一些复杂的替换操作，尽靠简单的字符匹配是不行的，我们看一个例子，若文本中有网络地址，我们想要a标签来包裹时，就需要用正则了。",
      "example": {
        "text": "Hello, ben@forta.com is my email address.",
        "reg": "(___w+[___w___.]*@[___w___.]+___.___w+)  --> 替换 <a href='mailto:$1'>$1</a>",
        "configs": "",
        "result": "Hello, <a href='mailto:ben@forta.com'>ben@forta.com</a> is my email address",
        "analyse": "替换操作需要用到俩个正则表达式：一个用来给出所说模式，另一个用来给出匹配文本的替换模式。回溯引用可以跨越模式使用，在第一个模式里被匹配的子表达式可以用在第二个模式里。这里使用的模式(___w+[___w.]*@[___w.]+.___w+)与我们以前使用的完全一样，但这次把它写成一个子表达式。这样一来，被匹配到的文本就可以用在替换模式里了。<a href='mailto:$1'>$1</a>使用了俩次被匹配的子表达式。从而得到了我们想要的结果。"
      }
    },
    "7.4": {
      "summary": "'有些'正则表达式实现允许使用一些元字符字母进行大小写转换。",
      "example": {
        "text": "<hh1>Welcome to my heome</hh1>",
        "reg": "(<hh1>)(.*?)(</hh1>) -> 替换 $1___U$2___E$3",
        "configs": "g",
        "result": "有些",
        "analyse": ""
      }
    },
    "8": {
      "summary": "我们用正则表达式匹配文本，有时还需要标记出文本的位置，这就前后查找（对某一位置的前、后内容进行查找）的概念。",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "8.1": {
      "summary": "我们还是先看一个例子：现在我们需要把一个web页面标题提取出来。",
      "example": {
        "text": "<head1><title1>Ben Forta Homepage</title1></head1>",
        "reg": "<title1>.*?</title1>",
        "configs": "g",
        "result": "<head1>_<title1>Ben Forta Homepage</title1>_</head1>",
        "analyse": "这个例子很简单，但是却有不足，我们只想匹配标题文本，但是这里却连title标签都匹配了。办法之一是使用子表达式，我们可以利用子表达式把被匹配的文本划分为3个部分：开始标签、标题文字、结束标签。把被匹配文本划分为多个部分之后，从它们当中提取且只提取我们需要的东西就很容易了。<br>可是，明知是自己并不真正需要的东西，（比如上面的title）还把它们检索出来岂不是毫无意义。“先把它们找出来，在以手动方式排除它们”这即浪费时间，又容易招致不必要的后患。在遇到这类问题时，需要这样一个模式，它包含的匹配本身并不返回，而是用于确定正确的匹配位置，它并不是匹配结果的一部分。换句话说，你需要进行“前后查找”。"
      }
    },
    "8.2": {
      "summary": "向前查找指定了一个必须匹配但不在结果中返回的模式。向前查找实际就是一个子表达式，而且从格式上看也确实如此。从语法上看，一个向前查找模式其实就是一个以?=开头的子表达式，需要匹配的文本跟在=的后面。<br>有些正则表达式文档使用术语“消费（consume）”来表述“匹配和返回文本”的含义。在向前查找里，被匹配的文本不包含在最终返回的匹配结果里，这被称为“不消费”。",
      "example": {
        "text": "http://www.forta.com/, https://mail.forta.com/, ftp://ftp.forta.com/",
        "reg": ".+(?=:)",
        "configs": "g",
        "result": "_http_://www.forta.com/, _https_://mail.forta.com/, _ftp_://ftp.forta.com/",
        "analyse": "上面列出的URL地址里，协议名与主机名之间以一个：分割。模式.+匹配任意文本（第1个匹配是http），子表达式(?=:)匹配:。注意被匹配到的:并没用出现最终的匹配结果里；我们用?=向正则表达式引擎表明：只要找到:就行了，不要把它包括在最终的匹配结果里----术语来说，就是“不消费”它。----如果把?=去掉看看结果，你会发现:也被匹配了，它被消费了。"
      }
    },
    "8.3": {
      "summary": "虽然JavaScript不支持向后查找，不过这里还是介绍下。<br>有许多正则表达式实现还支持向后查找，也就是查找出现在被匹配文本之前的字符（但不消费它），向后查找操作符是?<=。",
      "example": {
        "text": "ABC01: $23.34, HGG02: $5.31",
        "reg": "(?<=___$)[0-9.]+",
        "configs": "g",
        "result": "ABC01: $_23.34_, HGG02: $_5.31_",
        "analyse": "___$匹配$,[0-9]+匹配价格。但是多匹配了$，很显然去掉$也不能满足，然而在___$前面加了?<=修饰，标示不消费他，他就会只匹配数字。"
      }
    },
    "8.4": {
      "summary": "把向前查找和向后查找结合起来，提取标题文本的问题就十分容易了",
      "example": {
        "text": "<title1>Ben Forta Homepage</title1>",
        "reg": "(?<=<title1>).*?(?=</title1>)",
        "configs": "",
        "result": "_Ben Forta‘s HomePage_",
        "analyse": "没啥好分析了，很简单"
      }
    },
    "8.5": {
      "summary": "前后查找还有一种不太常见的用法叫做负前后查找。负向前查找（negative lookahead）将向前查找不与给定模式相匹配的文本，负向后查找（negative lookahead）将向后查找不与给定模式相匹配的文本。<br> 一般来说，凡是支持向前查找的正则表达式实现都同时支持正向前查找和负向前查找。类似地，凡是支持正则表达式实现都同时支持正向后查找和负向后查找。",
      "example": {
        "text": "I paid $30 for 100 apples, 50 oranges, and 60 pears. I saved $5 on this order.",
        "reg": "___b(?<!___$)___d+___b",
        "configs": "g",
        "result": "I paid $30 for _100_ apples, _50_ oranges, and _60_ pears. I saved $5 on this order.",
        "analyse": "___d+还是匹配数值，但这次只匹配数量，不匹配价格。表达式(?<!___$)是一个负向后查找，它使得最终的匹配结果只包含那些不以$开头的数值，仔细看上面正则前后分别用了___b，但是为何要这样做呢？"
      }
    },
    "9": {
      "summary": "嵌入条件",
      "example": {
        "text": "",
        "reg": "",
        "configs": "",
        "result": "",
        "analyse": ""
      }
    },
    "9.1": {
      "summary": "(123)456-7890和123-456-7890都是可接受的北美电话号码格式，而1234567890、(123)-456-7890和(123-456-7890)虽然都包含着数目正确的数字字符，但它们的格式都不对。如果要写个正则来匹配，要怎么写呢？这个问题看似简单，其实颇有难度。",
      "example": {
        "text": "123-456-7890,(123)456-7890,(123)-456-7890,(123-456-7890, 1234567890",
        "reg": "___(?___d{3}___)?-?___d{3}-___d{4}",
        "configs": "g",
        "result": "_123-456-7890_,_(123)456-7890_,_(123)-456-7890_,_(123-456-7890_, 1234567890",
        "analyse": "这个模式很简单，___(?匹配一个可有可无的左括号，___d{3}匹配3个数字，___)?匹配一个可有可无的右括号其他的都很简单。但是很显然这里还匹配到了第三第四俩不合法的字符。<br>正确的模式应该只在电话号码有一个左括号（的时候才去匹配）。更准确地说，应该是如果电话号码里有一个左括号（，我们的模式必须去匹配）；如果不是这样，他就必须去匹配-。这种模式如果不适用条件处理根本无法编写。并非所有的正则表达式实现都支持条件处理。javascript就不支持，骚味介绍下吧还是。"
      }
    },
    "9.2": {
      "summary": "正则表达式里的条件要用?来定义。嵌入条件语法也使用了?。<br>回溯引用条件只在一个前面的子表达式搜索取得成功的情况下才允许使用一个表达式，听起来很费解，我们还是用一个例子来说明好了：我们需要把一段文本里的标签全都找出来：不仅如此，如果某个标签是一个连接（被括在和标签之间）的话，还要把整个链接标签匹配出来。<br>用来定义这种条件的语法是?(backreference)true-regex)，其中?表明这是一个条件，括号里的backreference是一个回溯引用，true-regex是一个只在backreference存在时才会被执行的子表达式。",
      "example": {
        "text": "<td1><a1 href=''><img1 src='/images/home.gif/</a1><img1 src='/images/spacer.gif'></td1>",
        "reg": "(<[a1]___s+[^>]+>___s*)?<img1___s+[^>]+>(?(1)___s*</a1>)",
        "configs": "g",
        "result": "<td1><a1 href=''>_<img1 src='/images/home.gif/</a1>__<img1 src='/images/spacer.gif'>_</td1>",
        "analyse": "(<[a]___s+[^>]+>___s*)?将匹配一个标签，这个标签可有可无，接下来<img___s+[^>]+>匹配及其任意属性，(?(1)___s*</a>)是一个回溯引用条件----?(1)的含义是：如果一个回溯引用（具体到本例，就是标签）存在，则使用___s</[a]>继续进行匹配（换句话说，只有当前面的标签匹配成功，才继续进行后面的匹配）。如果(1)存在，___s</[a]>将匹配介绍标签之后出现的任意空白符。"
      }
    }
  }
}